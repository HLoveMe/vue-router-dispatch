{"version":3,"file":"pin.esm.dev.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AC5QA;AAGA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;ACrDA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AAEA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA","sources":["webpack://Pin/webpack/universalModuleDefinition","webpack://Pin/./src/RouterPin.ts","webpack://Pin/./src/initParams.ts","webpack://Pin/external umd \"rxjs\"","webpack://Pin/external umd \"rxjs/operators\"","webpack://Pin/external umd \"vue\"","webpack://Pin/external umd \"vue-router\"","webpack://Pin/webpack/bootstrap","webpack://Pin/webpack/runtime/compat get default export","webpack://Pin/webpack/runtime/define property getters","webpack://Pin/webpack/runtime/hasOwnProperty shorthand","webpack://Pin/webpack/runtime/make namespace object","webpack://Pin/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vue-router\"), require(\"rxjs\"), require(\"rxjs/operators\"), require(\"vue\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"vue-router\", \"rxjs\", \"rxjs/operators\", \"vue\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Pin\"] = factory(require(\"vue-router\"), require(\"rxjs\"), require(\"rxjs/operators\"), require(\"vue\"));\n\telse\n\t\troot[\"Pin\"] = factory(root[\"vue-router\"], root[\"rxjs\"], root[\"rxjs/operators\"], root[\"vue\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE_vue_router__, __WEBPACK_EXTERNAL_MODULE_rxjs__, __WEBPACK_EXTERNAL_MODULE_rxjs_operators__, __WEBPACK_EXTERNAL_MODULE_vue__) => {\nreturn ","import { BehaviorSubject, from, Observable, Subscription, zip } from \"rxjs\";\r\nimport { filter, takeLast, take, bufferCount, map } from 'rxjs/operators';\r\nimport { RouteLocationNormalized, RouteLocationRaw, Router, useRoute } from \"vue-router\";\r\nimport { initEvent, PolySymbol, ServerMap, SHALL_CURRENT, GlobalRServerKey, initEventKey, Global_Serve, CurrentRServerKey, noop } from \"./initParams\";\r\nimport { AsyncEvent, EventCallBack, ServerBase, ServerRoute, MessageSource, PinServer } from \"./type\";\r\nimport { shallowRef, App } from \"vue\";\r\n\r\nconst getCurrentServer = (current: RouteLocationNormalized) => {\r\n  var result: ServerRoute = {} as ServerRoute;\r\n  const { fullPath } = current;\r\n  const id = PolySymbol(fullPath)\r\n  const server = ServerMap.get(id);\r\n  if (server) {\r\n    result = server as ServerRoute;\r\n  } else {\r\n    result.id = PolySymbol(current.fullPath);\r\n    result.route = current;\r\n    result.children = [];\r\n    result.clearSubs = [];\r\n    result.channelCenter = new BehaviorSubject<AsyncEvent>(initEvent);\r\n  }\r\n  return result;\r\n}\r\nconst isEventType = (event: AsyncEvent, type: string | RegExp): boolean => {\r\n  if (type instanceof RegExp) {\r\n    if (typeof event.type !== 'string') return false\r\n    return type.test(event.type as string);\r\n  } else {\r\n    return event.type === type;\r\n  }\r\n};\r\nconst currentServer = shallowRef(SHALL_CURRENT);\r\n\r\nfunction removeSub(tran: ServerBase, sub: Subscription) {\r\n  sub.unsubscribe();\r\n  const index = tran.clearSubs.indexOf(sub);\r\n  index > -1 && (tran.clearSubs = tran.clearSubs.splice(index, 1));\r\n}\r\n\r\nfunction dispatch(tran: ServerBase, event: AsyncEvent, isAsync: boolean = false) {\r\n  const { channelCenter, id, errorChanel } = tran;\r\n  const isRoot = id === GlobalRServerKey;\r\n  if (isAsync === false) {\r\n    channelCenter.next(event);\r\n    isRoot && tran.children.forEach(child => child.channelCenter.next(event))\r\n    return\r\n  };\r\n  const { resolve, reject } = event;\r\n  const root = from(\r\n    new Promise<any>(\r\n      (resolve, reject) => {\r\n        channelCenter.next({\r\n          ...event,\r\n          resolve,\r\n          reject,\r\n        });\r\n      }));\r\n  const operators: Observable<any>[] = tran\r\n    .children\r\n    .map(\r\n      $1 => from(\r\n        new Promise((resolve, reject) => {\r\n          $1.channelCenter.next({\r\n            ...event,\r\n            resolve,\r\n            reject,\r\n          })\r\n        })));\r\n  zip(\r\n    root,\r\n    ...operators\r\n  ).pipe(\r\n    takeLast(1),\r\n  ).subscribe({\r\n    next: (promises: Array<any>) => resolve(promises),\r\n    complete: () => { },\r\n    error: (error: Error) => {\r\n      reject(error);\r\n      errorChanel.next(error);\r\n    }\r\n  })\r\n}\r\n\r\n\r\nfunction on(tran: ServerBase, type: string | RegExp, callback: EventCallBack) {\r\n  const { channelCenter, errorChanel } = tran;\r\n  const sub: Subscription = channelCenter\r\n    .pipe(\r\n      filter((event: AsyncEvent) => isEventType(event, type) || event.type === initEventKey),\r\n      bufferCount(2, 1),\r\n      map(events => events[1]),\r\n    )\r\n    .subscribe({\r\n      complete: () => removeSub(tran, sub),\r\n      next: event => callback && callback(event),\r\n      error: (error: Error) => errorChanel.next(error)\r\n    })\r\n  tran.clearSubs.push(sub);\r\n  return { close: () => removeSub(tran, sub) }\r\n}\r\n\r\nfunction once(tran: ServerBase, type: string | RegExp, callback: EventCallBack) {\r\n  const { channelCenter, errorChanel } = tran;\r\n  const sub: Subscription = channelCenter\r\n    .pipe(\r\n      filter((event: AsyncEvent) => isEventType(event, type) || event.type === initEventKey),\r\n      bufferCount(2, 1),\r\n      map(events => events[1]),\r\n      take(1),\r\n    )\r\n    .subscribe({\r\n      complete: () => removeSub(tran, sub),\r\n      next: event => callback && callback(event),\r\n      error: (error: Error) => errorChanel.next(error)\r\n    })\r\n  tran.clearSubs.push(sub);\r\n  return { close: () => removeSub(tran, sub) }\r\n}\r\nfunction onBehavior(tran: ServerBase, type: string | RegExp, callback: EventCallBack) {\r\n  const { channelCenter, errorChanel } = tran;\r\n  const sub: Subscription = channelCenter\r\n    .pipe(\r\n      filter(event => isEventType(event, type) && event.type !== initEventKey),\r\n    )\r\n    .subscribe({\r\n      complete: () => removeSub(tran, sub),\r\n      next: event => callback && callback(event),\r\n      error: (error: Error) => errorChanel.next(error)\r\n    })\r\n  tran.clearSubs.push(sub);\r\n  return { close: () => removeSub(tran, sub) }\r\n}\r\nfunction onError(tran: ServerBase, callback: Function) {\r\n  const { errorChanel } = tran;\r\n  const sub = errorChanel\r\n    .subscribe({\r\n      complete: () => {\r\n        removeSub(tran, sub);\r\n      },\r\n      next: error => {\r\n        callback && callback(error);\r\n      },\r\n    })\r\n  tran.clearSubs.push(sub);\r\n}\r\n\r\nexport const createRxFunc = (pin: ServerBase, source: MessageSource) => {\r\n  const router = Global_Serve.router;\r\n  // 只有router 可以指定在哪个pin触发\r\n  const getDispatchPin = (route?: RouteLocationRaw): ServerBase => {\r\n    if (!!route === false) return pin\r\n    const isRoot = pin.id === GlobalRServerKey;\r\n    if (!isRoot) return pin;\r\n    const { fullPath } = (router as Router).resolve(route as RouteLocationRaw)\r\n    const id = PolySymbol(fullPath)\r\n    const target = ServerMap.get(id);\r\n    return target || pin;\r\n  }\r\n  return {\r\n    dispatch: (type: string, data: any, route?: RouteLocationRaw) => {\r\n      dispatch(getDispatchPin(route), {\r\n        type,\r\n        data,\r\n        source,\r\n        resolve: () => { },\r\n        reject: () => { },\r\n      })\r\n    },\r\n    dispatchAsync: (type: string, data: any, route?: RouteLocationRaw) => {\r\n      return new Promise((resolve, reject) => {\r\n        dispatch(getDispatchPin(route), {\r\n          type,\r\n          data,\r\n          source,\r\n          resolve: (data: any) => resolve(data),\r\n          reject: (error: Error) => reject(error),\r\n        }, true)\r\n      })\r\n    },\r\n    on: (type: string, callback: EventCallBack) => {\r\n      return on(pin, type, callback);\r\n    },\r\n    onBehavior: (type: string, callback: EventCallBack) => {\r\n      return onBehavior(pin, type, callback);\r\n    },\r\n    once: (type: string, callback: EventCallBack) => {\r\n      return once(pin, type, callback);\r\n    },\r\n    onError: (callback: Function) => {\r\n      onError(pin, callback);\r\n    }\r\n  }\r\n}\r\n\r\nfunction createPinServer(): PinServer {\r\n  const init = (router: Router) => {\r\n    router.beforeEach((to: RouteLocationNormalized, from: RouteLocationNormalized) => {\r\n      const serve: ServerBase = getCurrentServer(to);\r\n      if (!ServerMap.has(serve.id)) Global_Serve.children.push(serve);\r\n      ServerMap.set(serve.id, serve);\r\n      currentServer.value = serve;\r\n    })\r\n    router.afterEach((to: RouteLocationNormalized, from: RouteLocationNormalized) => {\r\n      currentServer.value = getCurrentServer(to)\r\n    })\r\n\r\n    Global_Serve.channelCenter = new BehaviorSubject<AsyncEvent>(initEvent);\r\n    Global_Serve.router = router;\r\n    ServerMap.set(Global_Serve.id, Global_Serve);\r\n    currentServer.value = Global_Serve;\r\n  }\r\n  const Server = {\r\n    install(app: App) {\r\n      init(app.config.globalProperties.$router)\r\n      app.provide(GlobalRServerKey, Global_Serve);\r\n      app.provide(CurrentRServerKey, currentServer);\r\n      app.config.globalProperties.$rs = (type: string, data: any) => {\r\n        dispatch(currentServer.value, {\r\n          type,\r\n          data,\r\n          source: useRoute(),\r\n          resolve: () => { },\r\n          reject: () => { },\r\n        })\r\n      }\r\n    },\r\n    dispatch: (type: string, data: any, ...args: any[]) => {\r\n      let isAsync: boolean = false;\r\n      let target: RouteLocationRaw | undefined = undefined;\r\n      args = args.filter($1 => !!$1 === true)\r\n      if (args.length === 2) {\r\n        isAsync = args[0] as boolean;\r\n        target = args[1] as RouteLocationRaw;\r\n      } else if (args.length === 1) {\r\n        if (typeof args[0] === 'boolean') {\r\n          isAsync = args[0] as boolean;\r\n          target = undefined\r\n        } else {\r\n          target = args[0] as RouteLocationRaw;\r\n          isAsync = false;\r\n        }\r\n      }\r\n      let pin: ServerBase | undefined = undefined\r\n      if (!!target === false) pin = Global_Serve;\r\n      if (target === Global_Serve.router) pin = Global_Serve;\r\n      else {\r\n        const router = Global_Serve.router;\r\n        const { fullPath } = (router as Router).resolve(target as RouteLocationRaw)\r\n        const id = PolySymbol(fullPath)\r\n        pin = ServerMap.get(id);\r\n      }\r\n      return new Promise((resolve, reject) => {\r\n        dispatch(pin as ServerBase, {\r\n          type: type,\r\n          data: data,\r\n          source: undefined,\r\n          resolve: isAsync ? resolve : noop,\r\n          reject: isAsync ? reject : noop,\r\n        }, !!isAsync)\r\n        if (!isAsync) resolve(null)\r\n      })\r\n    }\r\n  }\r\n  return Server\r\n}\r\n\r\nconst Server: PinServer = createPinServer();\r\n\r\nexport default Server;","import { BehaviorSubject, Subject } from \"rxjs\";\r\nimport { AsyncEvent, RoutePin, RouterPin, ServerBase, ServerRouter } from \"./type\";\r\n\r\nfunction noop() { };\r\n\r\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\r\n\r\nconst PolySymbol = (name: string) =>\r\n  // vr = vue router\r\n  hasSymbol\r\n    ? Symbol.for('[r-server]: ' + name)\r\n    : ('[r-server]: ') + name;\r\n\r\nconst initEventKey = PolySymbol('event-init');\r\n\r\nconst GlobalRServerKey = PolySymbol('GlobalRServerKey');\r\n\r\nconst CurrentRServerKey = PolySymbol('CurrentRServerKey');\r\n\r\nconst ServerMap = new Map<string | symbol, ServerBase>();\r\n\r\nconst initEvent: AsyncEvent = { type: initEventKey, data: null, reject: noop, resolve: noop, source: undefined }\r\n\r\nconst SHALL_CURRENT: ServerBase = {\r\n  id: '',\r\n  channelCenter: new BehaviorSubject<AsyncEvent>(initEvent),\r\n  errorChanel: new Subject(),\r\n  children: [],\r\n  clearSubs: [],\r\n};\r\n\r\nconst Global_Serve: ServerRouter = {\r\n  id: GlobalRServerKey,\r\n  router: undefined,\r\n  children: [],\r\n  channelCenter: new BehaviorSubject<AsyncEvent>(initEvent),\r\n  errorChanel: new Subject(),\r\n  clearSubs: [],\r\n}\r\n\r\nconst emptyRunNoop = (): any => {\r\n  console.error('please install vue-router-pin')\r\n  return;\r\n}\r\nconst EmptyPin: RoutePin & RouterPin = {\r\n  on: emptyRunNoop,\r\n  onBehavior: emptyRunNoop,\r\n  once: emptyRunNoop,\r\n  onError: emptyRunNoop,\r\n  dispatch: emptyRunNoop,\r\n  dispatchAsync: emptyRunNoop,\r\n}\r\n\r\nexport {\r\n  GlobalRServerKey,\r\n  CurrentRServerKey,\r\n  SHALL_CURRENT,\r\n  Global_Serve,\r\n  ServerMap,\r\n  initEvent,\r\n  initEventKey,\r\n  PolySymbol,\r\n  noop,\r\n  EmptyPin,\r\n}","module.exports = __WEBPACK_EXTERNAL_MODULE_rxjs__;","module.exports = __WEBPACK_EXTERNAL_MODULE_rxjs_operators__;","module.exports = __WEBPACK_EXTERNAL_MODULE_vue__;","module.exports = __WEBPACK_EXTERNAL_MODULE_vue_router__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { useRoute, useRouter } from \"vue-router\";\r\nimport { CurrentRServerKey, GlobalRServerKey, EmptyPin } from \"./initParams\";\r\nimport Server, { createRxFunc } from \"./RouterPin\";\r\nimport { MessageSource, RoutePin, RouterPin, ServerRoute, ServerRouter } from \"./type\";\r\nimport { inject, ShallowRef } from \"vue\";\r\n\r\n/**\r\n * \r\n * @returns 当前路由派发\r\n */\r\nfunction useRoutePin(): RoutePin {\r\n  const currentServe: ShallowRef<ServerRoute> = inject(CurrentRServerKey) as ShallowRef<ServerRoute>;\r\n  if (!currentServe) {\r\n    return EmptyPin\r\n  }\r\n  return createRxFunc(currentServe.value, useRoute())\r\n}\r\n/**\r\n * \r\n * @returns 全局派发\r\n */\r\nfunction useRouterPin(): RouterPin {\r\n  const currentServe: ServerRouter = inject(GlobalRServerKey) as ServerRouter;\r\n  if (!currentServe) {\r\n    return EmptyPin\r\n  }\r\n  return createRxFunc(currentServe, useRouter());\r\n}\r\n\r\nfunction dispatchEvent(type: string, data: any, isAsync?: boolean, target?: MessageSource): Promise<any> {\r\n  return Server.dispatch(type, data, isAsync, target);\r\n}\r\n\r\nexport {\r\n  Server as VueRouterPin,\r\n  useRoutePin,\r\n  useRouterPin,\r\n  dispatchEvent,\r\n}"],"names":[],"sourceRoot":""}